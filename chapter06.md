# 6장 프로세스 정보
### 학습 목표
* 리눅스 시스템에서 프로세스가 무엇인지 이해한다.
* 함수를 사용해 프로세스의 속성을 검색할 수 있다.
* 프로세스의 실행 시간을 측정할 수 있다.
* 환경 변수를 설정하고 사용할 수 있다.
### 중요 개념
* 6.1 개요 : 
* 6.2 프로세스의 개념 : 
* 6.3 프로세스 식별 : 
* 6.4 프로세스 실행 시간 측정 : 
* 6.5 환경 변수의 활용 : 

## 예제 명세
### 6.2 프로세스의 개념
* 250 : 메모리 크기 검색(sysinfo(2))
### 6.3 프로세스 식별
* 000 : ...
### 6.4 프로세스 실행 시간 측정
* 000 : ...
### 6.5 환경 변수의 활용
* 000 : ...

## 6.1 개요
### 6.1.1 프로세스
#### 프로세스
* 프로세스 : 현재 실행 중인 프로그램
* 리눅스에서는 동시에 여러 프로세스가 실행 됨
* 계속 실행 상태에 있는 것은 아니며 규칙에 따라 여러 상태로 변함
* ps(1), top(1) : 현재 시스템에서 실행중인 프로세스 확인
#### 프로세스의 상태
* 실행
* 수면(sleep)
* 실행 대기
#### PID, 프로세스 그룹, 세션
* PID(프로세스 ID) : 시스템에서 프로세스를 식별하기 위해 사용하는 ID
* 프로세스 그룹(process group) : 관련 프로세스들이 모여 프로세스 그룹 형성
* 세션(session) : POSIX에서 제안한 개념으로, 사용자가 로그인해 작업하는 터미널 단위로 프로세스를 묶은 것
### 6.1.2 프로세스 관련 함수
#### 프로세스 식별 함수
```C
int sysinfo(struct sysinfo* info);  //메모리와 스왑 상태 검색
pid_t getpid(void);                 //PID 검색
pid_t getppid(void);                //부모 PID 검색
pid_t getpgrp(void);                //프로세스 그룹 ID 검색
pid_t getpgid(pid_t pid);           //프로세스 그룹 ID 검색
int setpgid(pid_t pid, pid_t pgid); //프로세스 그룹 ID 변경
pid_t getsid(pid_t pid);            //세션 리더 ID rjator
pid_t setsid(void);                 //세션 생성
```
#### 프로세스 실행 시간 측정 함수
```C
clock_t times(struct tms* buf); //프로세스 실행 시간 측정
```
* 시스템 사용 요금 결정, 시간소요가 많은 부분 찾기 등에 쓰임
* 프로세스 실행 시간의 구분
    * 시스템 실행 시간 : 프로세스에서 커널의 코드를 수행한 시간
    * 사용자 실행 시간 : 사용자 모드에서 프로세스를 실행한 시간
#### 프로세스 환경 설정 함수
```C
extenr char** environ;          //환경 설정 전역 변수사용
char* getenv(const char* name); //환경 변수 검색
int putenv(char* string);       //환경 변수 설정
int setenv(const char* name, const char* value, int overwrite);//환경 변수 설정
int unsetenv(const char* name); //환경 변수 삭제
```
* 기본 환경 : 모든 프로세스는 부모 프로세스(parent process)로부터 기본 환경을 물려받음
* 환경 변수(environment variable)를 사용해 프로세스 환경을 설정하거나 설정된 환경을 검색할 수 있음

## 6.2 프로세스의 개념
### 6.2.1 프로세스의 정의 
#### 프로세스
* 프로세스 : 실행 중인 프로그램 - 파일의 종류와 관계없이 실행파일을 메모리에 적재(load)하면 프로세스가 됨
* 프로세서 : CPU를 의미(프로세스를 처리함)
* 프로그램 : 명령어의 집합
#### 프로그램, 프로세스, 프로세서의 관계
* 프로그램
    * 소스파일
    * 실행 파일(소스 파일을 컴파일)
* 프로세스
    * 프로그램을 메모리에 적재
* 프로세서(CPU)
    * 프로세서를 실행
### 6.2.2 프로세스의 구조
* 스택(stack) 영역
    * 프로그램에서 정의한 지역 변수를 저장하는 메모리 영역
    * 지역 변수를 정의한 부분에서 할당해 사용함
* 빈 공간
    * 가변 영역(스택 영역, 힙 영역)의 가변적 메모리 할당을 위해 유지하고 있는 빈 메모리 영역
    * 이 영역이 모두 소진되면 메모리 부족으로 프로그램이 중단될 수 있음
* 힙(heap) 영역
    * 프로그램 실행 중에 동적으로 메모리를 요청하는 경우 할당되는 영역
    * 빈 영역 - 할당 - 할당 해제 과정으로 상태가 변함(가변 영역)
* 데이터 영역
    * 프로그램에서 정의한 전역 변수를 저장
    * 전역 변수는 프로그램 작성시 크기가 고정(고정 영역)
* 텍스트 영역
    * 실행 코드 저장
    * 프로세스 실행 중 크기가 변하지 않음(고정 영역)
* 가변 영역 : 스택, 빈 공간, 힙 영역
* 고정 영역 : 데이터, 텍스트 영역
### 6.2.3 프로세스 상태 변화
#### 프로세스의 상태 및 전이
* 1 : 사용자 모드 수행
* 2 : 커널 모드 수행
* 3 : 실행 대기(wait)
* 4 : 수면(sleep)
* 1 - 2 : 시스템 호출
* 2 - 2 : 인터럽트, 인터럽트 복귀
* 2 - 4 :
* 4 - 3 : 깨어남(wake up)
* 3 - 2 :
* 2 - 1 : 복귀
#### 프로세스 상태 전이 과정
* 프로세스는 사용자 모드에서 먼저 실행됨
* 사용자 모드에서 시스템 호출시 커널 모드로 전환되어 실행
* 수면 중이던 프로세스가 깨어나 실행 대기 상태가 되면 바로 실행할 수 있도록 준비함
* 커널 모드에서 실행 중 입출력 완료를 기다릴 때와 같이 실행을 더 이상 할 수 없을 때 수면 상태로 전환
#### 스케줄링
* 스케줄링 : 커널의 프로세스 관리 기능(프로세스의 상태를 적절히 변환)
* CPU : 한 번에 프로세스 하나만 실행 가능
* 한 개의 프로세스만 1 또는 2 상태에 있음
* 나머지는 3, 4 상태에 있음
* 수면 상태 : 사건(event)가 발생하기를 기다리는 상태
    * 입출력을 완료했을 때
    * 다른 프로세스가 종료되기를 기다릴 때
* 해당 사건이 발생하면 실행 대기 상태로 전환(스케줄링에 따라 수행됨)
### 6.2.4 프로세스 목록 보기
#### 프로세스 목록 보기 : ps(1)
```
$ ps #현재 터미널에서 실행한 프로세스만 출력
$ ps -ef | more #시스템에서 동작중인 전체 프로세스 보기
```
#### 시스템 메모리 정보 보기 : top(1)
```
$ top
```
* 프로세스 목록만 보여주는 것이 아님
* 시스템 부하 평균 정보(load average)를 아래의 정보를 통해 표시
    * 메모리
    * 스왑
    * 실행 중인 프로세스 수
    * ...
#### 메모리와 스왑 상태 검색 : sysinfo(2)
```C
#include<sys/sysinfo.h>
int sysinfo(struct sysinfo* info);
```
* sysinfo 구조체에 검색 결과를 저장해 리턴
* 성공시 : 0 리턴
* 실패시 : -1 리턴
#### sysinfo 구조체
```C
struct sysinfo{
    long uptime;            //시스템 부팅 후 경과된 시간을 초 단위로 저장
    unsigned long loads[3]; //시스템 부하 평균을 저장하는 배열(1, 5, 15분 기준)
    unsigned long totalram; //사용 가능한 총 메모리 크기 저장
    unsigned long freeram;  //사용 가능한 메모리 크기 저장
    unsigned long sharedram;//공유 메모리 크기 저장
    unsigned long bufferram;//버퍼가 사용하는 메모리 크기 저장
    unsigned long totalswap;//스왑 영역의 크기 저장
    unsigned long freeswap; //사용 가능한 스왑 영역의 크기 저장
    unsigned short procs;   //현재 실행 중인 프로세스 수 저장
    unsigned long totalhigh;//사용자에 할당된 메모리(high memory)의 총 크기 저장
    unsigned long freehigh; //사용 가능한 사용자 메모리 크기 저장
    unsigned int mem_unit;  //메모리 크기를 바이트 단위로 저장
    char _f[20-2*sizeof(long)-sizeof(int)]; //64바이트 크기를 맞추기 위한 패딩
}
```
#### 예제 250 : 메모리 크기 검색(sysinfo(2))
```C
#include<sys/sysinfo.h>
#include<stdio.h>

int main(void){
    struct sysinfo info;
    sysinfo(&info);

    printf("totalram : %ld\n", info.totalram);
    printf("freeram : %ld\n", info.freeram);
    printf("procs : %d\n", info.procs);
}
```
```
$ sh test.sh
totalram : 16592216064
freeram : 11948105728
procs : 797
```
#### 참고 : 스왑 영역, 패딩
* 스왑 영역 : RAM이 가득 찼을 때 임시로 사용하는 공간
* 패딩 : 읽는 대상에 메모리를 추가하여 성능 저하를 막는 것

## 6.3 프로세스 식별
### 
#### 
* ...

## 6.4 프로세스 실행 시간 측정
### 
#### 
* ...

## 6.5 환경 변수의 활용
### 
#### 
* ...